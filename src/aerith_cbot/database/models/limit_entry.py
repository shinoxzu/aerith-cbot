from sqlalchemy import BigInteger
from sqlalchemy.orm import Mapped, mapped_column

from .base import Base

"""
алгоритм такой:

есть LimitEntry — и для чата, и для пользователя там хранится инфа об их текущих лимитах.

пользователь пишет сообщение. если чат — группа, мы получаем лимит и для чата, и для пользователя.

если текущее_время - start_time > интервал_за_который_рефаются_сообщения,
то мы говорим, что 
remain = МАКС_СООБЩЕНИЙ (например, 50)
start_time = текущее время
првоеряем это и для лимита чата, и для лимита юзера в начале каждый раз

если текущее_время - start_time < интервал_за_который_рефаются_сообщения (для пользователя),
то мы проверяем, чему равен remai (пользователя).
— если remain >1, то remain -= 1 (и для пользователя, и для чата, если там можно вычесть)
и отдаем модели сообщение, как обычно.
— если remain == 1 (то есть это последнее сообщение пользователя), то:
    — если в текущий чат — группа, и в группе remain>1, то вычитаем из группы
    — если текущий чат не группа, или в группе тоже нет остатка по сообщениям, то 
    отправляем модели сообщение типа "попрощайся с ним, напиши, что тебе пора" и 
    вычитаем где можно из remain
— если remain == 0, то даже не даем это сообщение модели

* почему нельзя считать лимиты только для чата?
потому что юзеры смогут создавать новые чаты и расходовать токены там
* почему нельзя считать лимиты только для юзера?
потому что будет неловкая ситуация: модель попрощалась с одним пользователем в чате, но с другим общается
спокойно. а того, с кем попрощалась, будет игнорить.
"""


class LimitEntry(Base):
    __tablename__ = "limit_entries"

    # can be either chat_id or user_id
    object_id: Mapped[int] = mapped_column(BigInteger, primary_key=True)
    start_time: Mapped[int] = mapped_column(BigInteger, nullable=False)
    remain: Mapped[int] = mapped_column(nullable=False)

    def __repr__(self) -> str:
        return f"LimitEntry(\
        object_id={self.object_id}, \
        start_time={self.start_time}, \
        remain={self.remain})"
